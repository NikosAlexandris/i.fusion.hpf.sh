#!/bin/bash
# 29. Oct. 2013

# Source: ERDAS Documentation

SCRIPT=`basename $0`

# # check command line parameters
# if [ -z "${2}" ] ;
# then
# g.message "Name the Panchromatic and the three Multi-Spectral Images to be merged"
# g.message "Usage: $0 [Panchromatic Multi-Spectral(1) Multi-Spectral(2) Multi-Spectral(3)] "
# exit 1
# fi

#
# check if we have bc
#
if [ ! -x "`which bc`" ]
then echo "${SCRIPT}: bc required, please install it first" 2>&1
exit 1
fi

# Set Variables
PAN_IMAGE=${1}
MS_IMAGE_1=${2}
MS_IMAGE_2=${3}
MS_IMAGE_2=${4}


# HPF Resolution Merge  --- Attempt to replicate in GRASS GIS ################
                                                                             #

  # Function to combine high-resolution panchromatic data with lower resolution
  # multispectral data, resulting in an output with both excellent detail and
  # a realistic representation of original multispectral scene colors.

  # "HP Resolution Merge," researched and proposed by Ute Gangkofner of
  # Geoville, Inc. and Derrold Holcomb of ERDAS, Inc.

  # The process involves a convolution using a High Pass Filter (HPF) on the
  # high resolution data, then combining this with the lower resolution
  # multispectral data. Read the description of the Algorithm below.

  # Source: ERDAS IMAGINE 2013, Help Documentation

#
##############################################################################



# The general algorithm is:

#
# 1. Read pixel sizes from Image files and calculate R, the ratio of
# multispectral cell size to high-resolution cell size
# ----------------------------------------------------------------------------

eval `r.info ${MS_IMAGE} -g | grep res`
eval `r.info ${PAN_IMAGE} -g | grep res`

if [ ${nsres} == ${ewres} ]
  then eval MS_RESOLUTION="${nsres}"
  RATIO=$( echo "${MS_RESOLUTION} / ${PAN_RESOLUTION}" | bc )
  else g.message "North-South and East-West Resolutions do not match!"
fi



#
# 2. Apply the High-pass filter to the high spatial resolution image.
# ----------------------------------------------------------------------------

# # Use alternative level for the Filter's Center Cell Value?
# echo "Do you wish to use an alternative level for the High Pass Filter's center Cell value?"
# select yn in "Yes" "No"; do
#   case $yn in
# 	Yes ) select lh in "Low" "High"; do
# 	  case $lh in 
# 		Low ) Center_CellENTER_VALUE_LEVEL="LOW"
# 		High ) Center_CellENTER_VALUE_LEVEL="HIGH"
# 	  esac
# 	No ) exit;;
#   esac
# done

# Matrix Constructor Function -- Use as "HPF_MATRIX"
source HPF_Matrix_Constructor_Function.sh

# HPF Kernel Size, Center Value and Some Modulation Factor depend on RATIO

# 1 < RATIO < 2.5 then 5x5
if
  [[ $( echo "1 < ${RATIO}" | bc ) -eq 1 ]] && \
  [[ $( echo "${RATIO} < 2.5" | bc ) -eq 1 ]]

  then
  
	# kernel size
	Kernel_Size=5

	# potential center values
	Center_Default=24	;	Center_Low=28	;	Center_High=32
	
	# setting center value
	eval Center_Cell="Center_${Center_Level}"
	
	# modulation Factor
	Modulator_Min=0.3	;	Modulator_Default=0.25	;	Modulator_Max=0.20
	
	# setting modulation value
	eval Modulating_Factor="Modulator_${Modulating_Level}"
	
  # the Matrix
  HPF_Matrix ${Kernel_Size} ${HPF_Center_Cell}

	# Default will be:

	#   HPF_MATRIX=\
	# "MATRIX    5
	# -1 -1 -1 -1 -1
	# -1 -1 -1 -1 -1
	# -1 -1 $(echo ${Center_Cell}) -1 -1
	# -1 -1 -1 -1 -1
	# -1 -1 -1 -1 -1
	# DIVISOR   1
	# TYPE      P"

fi

# 2.5 <= RATIO < 3.5 then 7x7
if

  [[ $( echo "2.5 < ${RATIO}" | bc ) -eq 1 ]] && \
  [[ $( echo "${RATIO} < 3.5" | bc ) -eq 1 ]]
  then
  
	# kernel size
	Kernel_Size=7 #&& echo ${Kernel_Size}
	
	# center values
	Center_Default=48	;	Center_Low=56	;	Center_High=64
	
	# modulation factor
	Modulator_Min=0.65 ; Modulator_Default=0.50 ; Modulator_Max=0.35

  # the Matrix
  HPF_Matrix ${Kernel_Size} ${Center_Cell}

fi

# 3.5 <= RATIO < 5.5 then 9x9
if

  [[ $( echo "3.5 < ${RATIO}" | bc ) -eq 1 ]] && \
  [[ $( echo "${RATIO} < 5.5" | bc ) -eq 1 ]]
  then
  
	# kernel size
	Kernel_Size=9 #&& echo ${Kernel_Size}

	# center values 
	Center_Default=80	;	Center_Low=96	;	Center_High=106
	
	# modulation factor
	Modulator_Min=0.65 ; Modulator_Default=0.50 ; Modulator_Max=0.35

  # the Matrix
  HPF_Matrix ${Kernel_Size} ${Center_Cell}

fi

# 5.5 <= RATIO < 7.5 then 11x11
if

  [[ $( echo "5.5 < ${RATIO}" | bc ) -eq 1 ]] && \
  [[ $( echo "${RATIO} < 7.5" | bc ) -eq 1 ]]
  then
  
	# kernel size
	Kernel_Size=11 #&& echo ${Kernel_Size}

	# center values
	Center_Default=120 ; Center_Low=150 ; Center_High=180
	
	# modulation factor
	Modulator_Min=1.0 ; Modulator_Default=0.65 ; Modulator_Max=0.50

  # the Matrix
  HPF_Matrix ${Kernel_Size} ${Center_Cell}

fi

# 7.5 <= RATIO < 9.5 then 13x13
if

  [[ $( echo "7.5 < ${RATIO}" | bc ) -eq 1 ]] && \
  [[ $( echo "${RATIO} < 9.5" | bc ) -eq 1 ]]
  then
  
	# kernel size
	Kernel_Size=13 #&& echo ${Kernel_Size}
  
	# center values
	Center_Default=168	;	Center_Low=210	;	Center_High=252

	# modulation factor
	Modulator_Min=1.4 ; Modulator_Default=1.0 ; Modulator_Max=0.65

  # the Matrix
  HPF_Matrix ${Kernel_Size} ${Center_Cell}

fi

# RATIO >= 9.5 then 15x15
if

  [[ $( echo "9.5 <= ${RATIO}" | bc ) -eq 1 ]]
  then
  
	# kernel size
	Kernel_Size=15 #&& echo ${Kernel_Size}

	# center values
	Center_Default=336	;	Center_Low=392	;	Center_High=448
	
	# modulation factor
	Modulator_Min=2.0 ; Modulator_Default=1.35 ; Modulator_Max=1.0

  # the Matrix
  HPF_Matrix ${Kernel_Size} ${Center_Cell}

fi

# create filter ASCII file
echo "${HPF_MATRIX}" > HPF_FILE_${Kernel_Size}
g.message "High Pass Filter created with the following parameters:"
g.message "Kernel Size: ${Kernel_Size}; Center Value: ${Center_Cell}; Modulating Factor: ${Modulating_Factor}"

# create a temp file
Temporary_HPF=`g.tempfile pid=$$`
if [ $? -ne 0 ] || [ -z "$Temporary_HPF" ] ; then
g.message -e "unable to create temporary files"
exit 1
fi
	
# apply filter
r.mfilter.fp \
input="${PAN_IMAGE}" \
filter="HPF_FILE_${Kernel_Size}" \
output="${Temporary_HPF}" \
title="High Pass Filtered Panchromatic Image"



#
# 3. Resample the Multi-Spectral image to the pixel size of the high-pass image.
# Note, bilinear resampling required (4 nearest neighbours)!
# ----------------------------------------------------------------------------

# create a temp file
Temporary_MSBLNR=`g.tempfile pid=$$`
if [ $? -ne 0 ] || [ -z "$Temporary_MSBLNR" ] ; then
g.message -e "unable to create temporary files"
exit 1
fi

# resample
r.resamp.interp \
  method="bilinear" \
  input=${MS_IMAGE} \
  output=${Temporary_MSBLNR}


#
# 4. Add the HPF image weighted relative to the global standard deviation of
# the Multi-Spectral band.
# ----------------------------------------------------------------------------

# The weighting formula is: W = ( SD(MS) / SD(HPF) x M )
  # where:
	# SD(MS) and SD(HPF) are the Standard Deviations of the MS and HPF images
	# M is a Modulator value

# get Standard Deviations of Multi-Spectral Image(s) *and* the HPF Image
eval MS_STDDEV=`r.univar ${MS_IMAGE} -g | grep stddev`
eval HPF_STDDEV=`r.univar ${Temporary_HPF} -g | grep stddev`

# compute weighting
Weighting=$( echo "( ${MS_STDDEV} / ${HPF_STDDEV} * ${!Modulating_Factor} )" | bc )

# create temporary file
Temporary_MSHPF=`g.tempfile pid=$$`
if [ $? -ne 0 ] || [ -z "$Temporary_MSHPF" ] ; then
g.message -e "unable to create temporary files"
exit 1
fi

# Add weighted HPF image to the bilinearly resampled Multi-Spectral band
r.mapcalc "${Temporary_MSHPF} = ${Temporary_MSBLNR} + ${Temporary_HPF} * ${Weighting}"




#
# 5. Stretch linearly the new HPF-Sharpened image to match the mean and
# standard deviation of the input Multi-Sectral image.
# ----------------------------------------------------------------------------

# which module of formula?
input=${Temporary_MSHPF} \
output=MS_HPF_Sharpened \



#
# Clean up
#

# Remove temporary files
g.remove ${Temporary_HPF}
g.remove ${Temporary_MSBLNR}
g.remove ${Temporary_MSHPF}
